1. Why did you choose the tools, libraries, and language you used for the coding exercise?

I chose the tools and libraries based on my familiarity with them and their efficiency in handling API development, database interactions, and scalability. Compared to other techstack I know, FastAPI is straightforward and offers multiple libraries and features for rapid API development and automatic documentation. Its async capabilities are particularly useful for handling concurrent requests, which is crucial for a high-traffic rewards app like Fetch. I chose PostgreSQL and SQLAlchemy  as the database since it can manage structured data like points and payers well, and they can facilitate database interactions through an Object Relational Mapper (ORM). The ORM is basically having classes representing SQL tables, and their objects representing rows in those tables. From my past internship my application habit, I usually implement loggings and middleware functions to save the logs for further analysis and debugging (track the called API and their request and response bodies). Also, I can use middleware for further authentication steps to verify users to use specific APIs. I also use Pytest to test API functionality for different test cases. I usually want to write integration tests like I'm writing in this project to easily track the functionality of the previous APIs when I write the new one that might interact with them and possibly introduce new bugs. By using this, I can make sure my previous API in my earlier stage of development works well and maintain overall system integrity as the project grows.

2. What are the advantages and disadvantages of your solution?

My API design incorporates many test cases to ensure the robustness of the endpoints. These tests help identify cases where users might accidentally misuse the API, allowing the system to handle those situations. In the /spend endpoint, I designed the API to query the minimum number of rows that sum up to the amount a user wants to spend. These rows are ordered by their creation time (created_at). This approach optimizes the query process, avoiding inefficient loops, and makes the execution faster. This can avoid looping through the rows and thus make the query faster. This is the API with the most complex business requirements, and I think for the future, there will be some new cases introduced to this API. For example, when a user receives a refund, the API should update the corresponding row in the USER_PAYER table (for points and updated_at). This ensures the consistency of the data. That is why I think my database design in separating the attributes of different entities (user, payer) is also one of my advantages. However, one of the most significant disadvantages can be from the fact that users can add negative points. When users add negative points, it requires querying all rows for a specific payer and user to ensure the total points don’t drop below zero. This query can slow down the API, particularly as the dataset grows. I recognize that I need to implement more efficient handling for this scenario to optimize performance. Also for further development, I think I should clarify more about the negative points and handle it differently in other functions or endpoints. Also, due to the specified prompt, I didn’t fully specify the path and the response body I intended. For example, I intended the response returned by the “/balance” endpoint to just the amount of points users have. Only admin users should have the ability to view certain details. This helps protect sensitive data.

3. What has been a favorite school/personal project thus far? What about it that challenged you?
So far, one of my favorite personal projects is an app that tracks users' moods based on their song preferences. The app analyzes users' favorite songs to monitor and infer their mood. I enjoyed this project because it allowed me to learn a new tech stack—Kotlin for Android development—and to customize the app based on my own ideas and preferences.

In addition to front-end development, I also handled the backend, which involved self-teaching concepts like working with external APIs such as the Spotify API, implementing OAuth2 authentication flow. These were challenges because I had to quickly grasp new concepts while actively developing my ideas. Moreover, designing a database, APIs and translating my app concept into code using technologies I had just learned was time-consuming but rewarding. I loved the process of learning and seeing my app take shape day by day.
